<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SOLID Principles</title>
<style>
body{
    font-family: "Segoe UI", Arial, sans-serif;
    background:#eef2f7;
    margin:0;
    padding:40px;
}
.container{
    max-width:900px;
    margin:auto;
    background:white;
    padding:40px;
    border-radius:12px;
    box-shadow:0 8px 24px rgba(0,0,0,0.1);
}
h1{
    text-align:center;
    margin-bottom:30px;
}
.section{
    margin-bottom:40px;
}
.section h2{
    border-left:6px solid #4f7cff;
    padding-left:12px;
}
pre{
    background:#1e1e1e;
    color:#f1f1f1;
    padding:18px;
    border-radius:8px;
    overflow-x:auto;
}
ul{
    line-height:1.7;
}
.note{
    background:#f4f7ff;
    padding:15px;
    border-left:4px solid #4f7cff;
    margin:20px 0;
}
</style>
</head>
<body>
<div class="container">
<h1>SOLID Principles</h1>

<div class="section">
<h2>SOLID</h2>
<ul>
<li><strong>S</strong> - Single Responsibility Principle</li>
<li><strong>O</strong> - Open / Closed Principle</li>
<li><strong>L</strong> - Liskov Substitution Principle</li>
<li><strong>I</strong> - Interface Segmented Principle</li>
<li><strong>D</strong> - Dependency Inversion Principle</li>
</ul>

<h3>Advantages of following these principles:</h3>
<ul>
<li>(i) Help us to write better code</li>
<li>(ii) Avoid duplicate code</li>
<li>(iii) Easy to maintain</li>
<li>(iv) Easy to understand</li>
<li>(v) Flexible software</li>
<li>(vi) Reduce complexity</li>
</ul>
</div>

<div class="section">
<h2>1. S - Single Responsibility Principle</h2>
<p>A class should have 1 reason to change.</p>

<h4>Marker Entity:</h4>
<pre>
class Marker {
    String name;
    String color;
    int year;
    int price;
    
    public Marker(String name, String color, int year, int price) {
        this.name = name;
        this.color = color;
        this.year = year;
        this.price = price;
    }
}
</pre>

<h4>Invoice class (Violating SRP):</h4>
<pre>
class Invoice {
    private Marker marker;
    private int quantity;
    
    public Invoice(Marker marker, int quantity) {
        this.marker = marker;
        this.quantity = quantity;
    }
    
    public int calculateTotal() {
        int price = ((marker.price) * this.quantity);
        return price;
    }
    
    public void printInvoice() {
        // print the Invoice
    }
    
    public void saveToDB() {
        // Save the data into DB
    }
}
</pre>

<div class="note">
The above Invoice class has 3 reasons to change. So, it doesn't follow Single Responsibility Principle.
</div>

<h4>Then how can it follow?</h4>

<p><strong>(i) Invoice class (only calculation):</strong></p>
<pre>
class Invoice {
    private Marker marker;
    private int quantity;
    
    public Invoice(Marker marker, int quantity) {
        this.marker = marker;
        this.quantity = quantity;
    }
    
    public int calculateTotal() {
        int price = ((marker.price) * this.quantity);
        return price;
    }
}
</pre>

<p><strong>(ii) InvoiceDao class (only database operations):</strong></p>
<pre>
class InvoiceDao {
    Invoice invoice;
    
    public InvoiceDao(Invoice invoice) {
        this.invoice = invoice;
    }
    
    public void saveToDB() {
        // Save the data into DB
    }
}
</pre>

<p><strong>(iii) InvoicePrinter class (only printing):</strong></p>
<pre>
class InvoicePrinter {
    private Invoice invoice;
    
    public InvoicePrinter(Invoice invoice) {
        this.invoice = invoice;
    }
    
    public void printInvoice() {
        // print the Invoice
    }
}
</pre>
</div>

<div class="section">
<h2>2. O - Open/Closed Principle</h2>
<p>Open for Extension but closed for Modification</p>

<h4>InvoiceDao class (Violating OCP):</h4>
<pre>
class InvoiceDao {
    Invoice invoice;
    
    public InvoiceDao(Invoice invoice) {
        this.invoice = invoice;
    }
    
    public void saveToDB() {
        // Save the data into DB
    }
}
</pre>

<h4>Modified InvoiceDao (Still Violating OCP):</h4>
<pre>
class InvoiceDao {
    Invoice invoice;
    
    public InvoiceDao(Invoice invoice) {
        this.invoice = invoice;
    }
    
    public void saveToDB() {
        // Save the data into DB
    }
    
    public void saveToFile(String file_name) {
        // Save invoice in the file with the given name
    }
}
</pre>

<div class="note">
This is not following Open/Closed Principle as we are not extending it but modifying the pre-written code which might be actually tested and live in production.
</div>

<h4>Then how can it follow Open/Closed Principle?</h4>

<pre>
interface InvoiceDao {
    public void save(Invoice invoice);
}
</pre>

<pre>
class DatabaseInvoiceDao implements InvoiceDao {
    @Override
    public void save(Invoice invoice) {
        // Save to DB
    }
}
</pre>

<pre>
class FileInvoiceDao implements InvoiceDao {
    @Override
    public void save(Invoice invoice) {
        // Save to file
    }
}
</pre>
</div>

<div class="section">
<h2>3. L - Liskov Substitution Principle</h2>
<p>- If class B is subtype of class A, then we should be able to replace object of A with B without breaking the behaviour of the program.</p>
<p>- Subclass should extend the capability of parent class not narrow it down.</p>

<pre>
interface Bike {
    void turnOnEngine();
    void accelerate();
}
</pre>

<pre>
class Motorcycle implements Bike {
    boolean isEngineOn;
    int speed;
    
    public void turnOnEngine() {
        // turn on the engine!
        isEngineOn = true;
    }
    
    public void accelerate() {
        // increase the speed
        speed = speed + 10;
    }
}
</pre>

<pre>
class Bicycle implements Bike {
    
    public void turnOnEngine() {
        throw new AssertionError("there is no engine");
    }
    
    public void accelerate() {
        // do something
    }
}
</pre>

<div class="note">
It breaks the behaviour of the code because if someone calls bicycle.turnOnEngine(), the user expects the engine to be turned on but instead it's throwing error.
</div>
</div>

<div class="section">
<h2>4. I - Interface Segmented Principle</h2>
<p>Interfaces should be such, that client should not implement unnecessary functions they do not need.</p>

<h4>RestaurantEmployee interface (Violating ISP):</h4>
<pre>
interface RestaurantEmployee {
    void washDishes();
    void serveCustomers();
    void cookFood();
}
</pre>

<pre>
class Waiter implements RestaurantEmployee {
    
    public void washDishes() {
        // not my job
    }
    
    public void serveCustomers() {
        // yes and here is my implementation
        System.out.println("serving the customer");
    }
    
    public void cookDishes() {
        // not my job
    }
}
</pre>

<div class="note">
But this breaks the implementation, because it is not waiter's job to wash dishes or cook the dish. But since it is implementing the interface, the client (waiter) has to implement all those functions.
</div>

<h4>Then how can it follow Interface Segmented Principle?</h4>

<pre>
interface WaiterInterface {
    void serveCustomers();
    void takeOrder();
}

interface ChefInterface {
    void cookFood();
    void decideMenu();
}
</pre>

<pre>
class Waiter implements WaiterInterface {
    
    public void serveCustomers() {
        System.out.println("serving the customers");
    }
    
    public void takeOrder() {
        System.out.println("taking orders");
    }
}
</pre>

<pre>
class Chef implements ChefInterface {
    
    public void cookFood() {
        System.out.println("cooking food");
    }
    
    public void decideMenu() {
        System.out.println("deciding menu");
    }
}
</pre>
</div>

<div class="section">
<h2>5. D - Dependency Inversion Principle</h2>
<p>Class should depend on interfaces rather than concrete classes.</p>

<h4>Interface Hierarchy:</h4>
<p style="text-align:center; margin:20px 0;">
<strong>INTERFACES</strong><br><br>
Mouse Interface → Wired Mouse, Bluetooth Mouse<br>
Keyboard Interface → Wired Keyboard, Bluetooth Keyboard
</p>

<h4>Macbook class (Violating DIP):</h4>
<pre>
class Macbook {
    private final WiredKeyboard keyboard;
    private final WiredMouse mouse;
    
    public Macbook() {
        keyboard = new WiredKeyboard();
        mouse = new WiredMouse();
    }
}
</pre>

<div class="note">
But since keyboard is of type WiredKeyboard, in future even if we want to change it to BluetoothKeyboard, we can't because it's of type WiredKeyboard.
</div>

<h4>Then how can it follow Dependency Inversion Principle?</h4>

<pre>
class Macbook {
    private final Keyboard keyboard;
    private final Mouse mouse;
    
    public Macbook(Keyboard keyboard, Mouse mouse) {
        this.keyboard = keyboard;
        this.mouse = mouse;
    }
}
</pre>
</div>

</div>
</body>
</html>